%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter2.tex}%

\chapter{Fundamentals and State of the Art}
\label{cha:fundamentals_state_of_the_art}

\section{Introduction}
\label{sec:Introduction}

This chapter provides the conceptual and technical foundations that support the work to be developed in this dissertation. It begins by introducing the CAMARA project, explaining its role in the standardization of network APIs. Subsequently, the  CAMARA APIs selected for this study are examined, which will create the basis for the practical work to be developed later. The chapter concludes with an analysis of real-world use cases that demonstrate the applicability and reliance of CAMARA-based APIs.

To understand the purpose and design of the CAMARA project, it helps to first clarify the main ideas behind programmability and capability exposure in modern 5G networks. Current fifth-generation systems represent a shift toward software-driven architectures, where tools like Software-Defined Networking (SDN) and Network Function Virtualization (NFV) give operators much more freedom in how they configure and manage network behaviour \cite{BARAKABITZE2020106984, BONATI2020107516}. However, for this flexibility to be useful beyond the operator’s own systems, it also needs to be made available to external applications and service providers. This is enabled through standardized exposure mechanisms, with 3GPP’s northbound interfaces serving as the primary framework for this interaction \cite{MICHAELIDES2025107645}.

In this context, network APIs function as an abstraction layer that presents complex network capabilities in a more manageable and secure form. They reduce the need for developers to engage directly with detailed network operations while still maintaining interoperability across different systems \cite{BONATI2020107516}. These concepts are important for understanding CAMARA’s effort to provide a common approach to API exposure among operators, and they offer the technical background needed for the discussion of the selected CAMARA APIs later in the chapter.

\section{The CAMARA Project}
\label{sec:camara_project}

    \subsection{Origins and Motivation}
    \label{subsec:camara_origins}

    Before the emergence of CAMARA, mobile network operators were already exposing a limited set of network capabilities to external systems through APIs. In practice, these exposure mechanisms were developed independently by each operator and reflected local design choices rather than a shared architectural vision. This resulted in proprietary interfaces, differing data models, and variations in behaviour between networks. From the perspective of application developers, such differences meant that integrations were often closely tied to a specific operator, making it difficult to reuse applications across networks. The resulting fragmentation was not primarily due to technical limitations, but instead to the lack of a common, standardized approach to network API exposure across the wider telecommunications ecosystem \cite{BONATI2020107516, BARAKABITZE2020106984}.

    From an application development perspective, fragmentation created a range of technical and operational difficulties. Applications that relied on network capabilities rarely worked across operators without modification. In most cases, developers had to adapt the application to each operator’s API, which increased development effort and maintenance costs over time. Deploying the same service on multiple networks was therefore difficult. It was often slow and required additional work, limiting scalability and slowing innovation. For developers and service providers outside the telecommunications domain, these constraints were especially significant, as they usually lacked the resources to support multiple operator-specific integrations. Without a unified exposure model, building portable and network-aware applications that behaved consistently across different mobile networks remained challenging \cite{BONATI2020107516, MICHAELIDES2025107645}.

    As these limitations became clearer over time, it was increasingly accepted within the telecommunications industry that a common approach to network API exposure was needed. Continuing with separate, operator-specific solutions proved inefficient and difficult to scale. Instead, attention shifted toward exposing network capabilities through shared interfaces with stable semantics and predictable behavior. This made it possible for applications to be built once and used across different networks with minimal adaptation. In doing so, mobile networks moved closer to the logic of the wider API economy. The network therefore began to be treated less as a set of isolated systems and more as a programmable platform that could support broader innovation and easier third-party adoption \cite{BONATI2020107516, Raza:17}.

    In response to the growing need for harmonization in network API exposure, the CAMARA project was launched as a joint initiative involving the GSMA and the Linux Foundation. The project was conceived to address fragmentation in operator-specific APIs by defining a common, open framework for exposing network capabilities. The GSMA provides the industry alignment required to ensure adoption across mobile network operators, while the Linux Foundation contributes an open-source governance model that promotes transparency and collaborative development. Through this combined organizational and technical approach, CAMARA establishes a neutral environment in which operators, vendors, and developers can jointly define standardized APIs. As a result, CAMARA positions itself not only as a technical specification effort, but also as an industry-wide coordination mechanism aimed at enabling consistent and scalable access to network capabilities \cite{camara_presentation, camara_scope}.

    The CAMARA project outlines specific objectives for the exposure and consumption of network capabilities. CAMARA aims to simplify network access by masking operator-specific details behind a common API framework. This standardization removes the requirement for custom integration with each operator, allowing for faster development cycles. The project also addresses scalability, enabling the deployment of network-aware applications across multiple providers without extensive adaptation. This consistency is a prerequisite for a fully open telecommunications environment \cite{camara_presentation, camara_scope}.

    \subsection{CAMARA Architecture and Principles}
    \label{subsec:camara_architecture}

    At a high level, the CAMARA architecture is designed as an intermediate layer between external applications and the underlying mobile network infrastructure. Its primary role is to provide a standardized and technology-agnostic interface through which network capabilities can be accessed, while hiding the internal complexity of operator networks. Applications, hyperscalers, and aggregators interact with the network exclusively through CAMARA-defined northbound APIs, whereas the actual realization of these capabilities remains encapsulated within operator-specific exposure platforms. This layered approach allows network functions to be exposed in a uniform manner, independently of the technologies and implementations used within each operator’s network.

    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.95\textwidth]{../Figures/Images/camara_architecture.png}
    \caption{High-level CAMARA Architecture. Source: CAMARA Project website \cite{camara_scope}.}
    \label{fig:camara_architecture}
    \end{figure}

    Figure~\ref{fig:camara_architecture} illustrates this high-level architectural view, highlighting the separation between API consumers, the CAMARA exposure layer, and the underlying network capabilities.

    A central aspect of the CAMARA architecture is the clear separation between network implementation, capability exposure, and application use. Network operators keep full control over their internal functions and underlying technologies. CAMARA, by contrast, focuses only on defining standardized interfaces and common behavioral rules for exposing these capabilities. This separation allows different network technologies to operate behind a shared API layer, without exposing implementation details to application developers. As a result, the architecture supports interoperability and portability while preserving operator autonomy and flexibility in how network capabilities are implemented \cite{camara_presentation, camara_scope}.

    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{../Figures/Images/TransformationFunction-1.png}
    \caption{Service API abstraction through transformation functions. Source: CAMARA Project website \cite{camara_scope}.}
    \label{fig:camara_transformation}
    \end{figure}

    Figure~\ref{fig:camara_transformation} further illustrates how heterogeneous network and IT capabilities can be abstracted behind a unified service API layer through transformation functions.

    By decoupling capability exposure from network implementation, the CAMARA architecture enables a scalable and evolvable model for network API standardization. This architectural approach supports multi-operator adoption while allowing network capabilities to evolve independently of the interfaces exposed to applications. These principles provide the foundation for the API exposure model discussed in the following section \cite{camara_presentation, camara_scope}.


    \subsection{API Exposure Model}
    \label{subsec:api_exposure_model}

    In the CAMARA context, API exposure describes how selected network capabilities are made available to external applications in a controlled and standardized way. Applications are not given direct access to internal network functions. Instead, CAMARA defines abstract interfaces that represent these capabilities without depending on specific technologies. These interfaces serve as a contract between the network and application layers. They describe how each capability behaves while hiding implementation details. This makes it easier for applications to use network functions in the same way across different operators, even when their underlying networks are implemented differently \cite{camara_scope}.

    A central goal of the CAMARA exposure model is to ensure that network APIs behave in a similar way across different operators. CAMARA defines shared semantics and interaction patterns to limit differences in how operators expose network capabilities. This reduces the extent to which applications must handle operator-specific behavior. Developers can therefore build network-aware applications that run across multiple networks with only small adjustments. In this way, the exposure model supports portability and scalability in multi-operator environments and large-scale deployments \cite{camara_scope}.

    Together, these characteristics define an exposure model that abstracts network complexity while enabling reliable and repeatable interaction with network capabilities. By formalizing how capabilities are exposed and consumed, CAMARA establishes a foundation that supports multi-operator interoperability and large-scale application deployment. This exposure model is a key enabler for treating network capabilities as consumable services, an idea that is further explored in the context of Network-as-a-Service and the GSMA Open Gateway initiative in the following section.


    \subsection{NaaS and Open Gateway}
    \label{subsec:naas_open_gateway}

    Network-as-a-Service (NaaS) refers to the use of network capabilities as services that can be requested when needed. Instead of being tightly bound to specific network infrastructure, these capabilities are accessed through defined interfaces. Standardized network APIs are therefore required to make this approach practical for application developers. CAMARA contributes by providing a common API framework for exposing network capabilities in a consistent way. This allows the same approach to be applied across different operators and network implementations \cite{camara_scope}.

    Within this context, the GSMA Open Gateway initiative provides a coordinated framework for aligning network API exposure across operators at a global scale. Rather than defining new APIs itself, Open Gateway establishes a common industry vision and adoption model, relying on the CAMARA project as the technical reference for standardized network APIs. Through this alignment, operators can expose network capabilities using consistent interfaces while participating in a broader, interoperable ecosystem that supports multi-operator deployment and large-scale application development \cite{camara_scope}.

    Together, the NaaS paradigm and the GSMA Open Gateway initiative provide the broader context in which CAMARA operates as a technical enabler for standardized network APIs. While Open Gateway focuses on coordination, adoption, and scale, CAMARA delivers the technical specifications that make this vision actionable. This alignment explains how network capabilities can be exposed consistently across operators and sets the stage for understanding the global rollout and availability of CAMARA APIs discussed in the following section.

    \subsection{API Launch Status Worldwide}
    \label{subsec:api_launch_status}

    The worldwide launch of CAMARA APIs is currently progressing through coordinated initiatives led by the GSMA Open Gateway. Multiple mobile network operators have announced participation and initial deployments, indicating a transition from specification to practical adoption. However, the availability and maturity of exposed APIs vary across regions and operators, reflecting different stages of implementation and market readiness \cite{gsma_opengateway_site}.

    This uneven rollout highlights the evolving nature of the CAMARA ecosystem and explains why implementations may differ between operators. At the same time, the existence of real deployments demonstrates that standardized network APIs are moving beyond conceptual frameworks toward operational use, providing relevant context for the analysis of operator-specific implementations presented later in this chapter.

    \subsection{CAMARA APIs as a Service}
    \label{subsec:camaraas}

    The concept of offering CAMARA APIs as a service builds on the idea that network capabilities should be consumed through managed, service-oriented interfaces rather than as isolated technical endpoints. In this model, APIs are provided through platforms that support onboarding, access control, monitoring, and lifecycle management, enabling developers to integrate network capabilities in a controlled and scalable manner. While CAMARA primarily defines the technical specifications of network APIs, early demonstrations have shown how these APIs can be delivered and consumed as a service within real operational environments, validating the feasibility of this approach without constraining it to a single implementation \cite{camara_presentation, 11152879}.

    This service-oriented perspective complements the architectural principles defined by CAMARA by focusing on how standardized APIs can be delivered and consumed in practice. By abstracting operational complexity behind managed platforms, the CAMARA APIs as a Service model provides a bridge between specification and deployment. This perspective naturally leads to the discussion of reference architectures that illustrate how CAMARA components can be integrated within operator environments, which is addressed in the following section.

    \subsection{Reference Architecture}
    \label{subsec:reference_architecture}

    To support the standardized exposure of network capabilities, CAMARA defines a reference architecture that separates the roles of application consumers, exposure or aggregation platforms, and mobile network operators. This separation keeps the complexity of the underlying network out of the application domain. At the same time, it provides a consistent and secure interface through which APIs can be accessed.

    At a high level, the architecture consists of three logical layers. The application layer includes third-party services that consume CAMARA APIs. The exposure or aggregation layer acts as a single entry point and manages access to multiple operators. The operator layer contains the network capabilities implemented within each mobile network. By defining these layers and their boundaries, CAMARA supports interoperability across operators while allowing each operator to retain flexibility in how capabilities are implemented internally.

    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.95\textwidth]{../Figures/Images/NaaSServiceStandardization.png}
    \caption{Reference architecture for standardized network capability exposure in CAMARA. Source: CAMARA Project website
    \cite{camara_scope}.}
    \label{fig:camara_reference_architecture}
    \end{figure}

    Figure~\ref{fig:camara_reference_architecture} illustrates this reference architecture, highlighting how standardized service APIs abstract heterogeneous network and IT capabilities behind a common exposure layer.

    \subsection{CAMARA API Catalog}
    \label{subsec:camara_api_catalog}

    The CAMARA API Catalog defines the standardized network APIs provided by the CAMARA project. Each API represents a specific network capability and follows a common structure and set of behaviors. This allows applications to interact with network functions in a consistent way across different operators. The APIs are organized around exposed capabilities rather than underlying network technologies. As a result, implementation details are hidden, and applications can be developed in a more portable and interoperable manner \cite{camara_api_overview}.

    In practice, the APIs included in the CAMARA catalog represent a shared reference rather than a mandatory implementation set. Mobile network operators may choose to implement a subset of the available APIs depending on technical readiness, regulatory considerations, and business priorities. For this reason, the following section focuses on the specific set of CAMARA APIs selected for this dissertation, which form the technical basis for the analysis and use cases developed later \cite{camara_scope}.

\section{CAMARA APIs - Technical Overview}
\label{sec:selected_camara_apis}

    \subsection{Overview and API Classification}
    \label{subsec:Overview_and_API_classification}
    
    This section presents an implementation-oriented overview of the CAMARA APIs and places them within the wider CAMARA ecosystem. The intention is not to analyse individual API specifications in detail, but to organize the available APIs according to the network capabilities they expose. This provides a clear starting point for the operator-specific analysis that follows.

    In the CAMARA project, network APIs are defined by the capabilities they expose rather than by the network technologies used to implement them. This makes it possible for application developers to work with network functionality at a higher level, without needing to understand operator-specific details. On this basis, APIs can be grouped into functional domains such as authentication and fraud prevention, location services, device information, and communication quality management.
    
    For the purposes of this dissertation, only CAMARA APIs that are considered mature are taken into account. These APIs are regarded as stable and suitable for practical use, and they represent capabilities that are sufficiently standardized for deployment across multiple operators.
    
    Table~\ref{tab:camara_api_classification_final} in Annex~\ref{ann:lorem_ipsum1} provides an overview of the mature CAMARA APIs examined in this work, grouped by capability category and based on the official CAMARA API overview \cite{camara_api_overview}.

    The following section contextualizes this general classification by examining the subset of CAMARA APIs made available within a specific operator environment.

    \subsection{Selected CAMARA APIs}
    \label{subsec:selected_apis}

    To support the development of this dissertation, a specific subset of CAMARA APIs was selected for analysis and experimentation. These APIs were chosen based on their maturity within the CAMARA project and their relevance to the proposed use cases. The selection focuses on APIs that are readily available in standard reference implementations and sandbox environments, enabling practical validation of interaction flows between applications and network capabilities.
    
    In total, six CAMARA APIs are analyzed in this work. These APIs cover key network capabilities that are representative of the CAMARA ecosystem and suitable for practical experimentation. The selected APIs are: SIM Swap, Device Identifier, Location Retrieval, Location Verification, Quality of Service Profiles, and Quality on Demand.
    
    In the following section, each of these APIs is described in detail, including its functionality, invocation model, and technical characteristics.

    \subsection{APIs Explained}
    \label{subsec:apis_explained}

    \subsubsection{Device Identifier}
    \label{subsubsec:device_identifier}
    
    \paragraph{Introduction}
    The Device Identifier API provides a standardized mechanism for applications to query the mobile network regarding the physical characteristics of the device associated with a specific subscription. Unlike the user identity (linked to the SIM card/IMSI), the device identity is linked to the hardware itself, primarily through the International Mobile Equipment Identity (IMEI) or the Pairwise Pseudonymous Identifier (PPID). This API enables the resolution of a network connection or subscription identifier into a stable physical device identifier \cite{camara_device_identifier}.
    
    \paragraph{Motivation}
    Mobile applications typically function within restricted environments imposed by operating systems, which often prevent direct access to sensitive hardware identifiers like the IMEI. While a user can technically retrieve this information manually, the process is prone to transcription errors and friction. The Device Identifier API automates this retrieval, overcoming access limitations and eliminating manual errors. This results in operational efficiency for the API consumer and ensures trusted data verification directly from the network operator's registry.
    
    \paragraph{Functionality}
    The CAMARA specification defines three primary resources to retrieve device information based on the level of detail required:
    \begin{itemize}
        \item {Retrieve Identifier (`/retrieve-identifier`):} Returns the full unique identifier of the device, specifically the IMEI (15 digits) or the IMEI Software Version (IMEISV, 16 digits).
        \item {Retrieve Type (`/retrieve-type`):} Returns only the manufacturer, model, and Type Allocation Code (TAC), without exposing the unique serial number of the user's equipment.
        \item {Retrieve Pseudonym (`/retrieve-ppid`):} Returns a pseudonymised identifier (PPID) that is unique to the API consumer but persistent for the device, enabling privacy-preserving tracking.
    \end{itemize}
    
    \paragraph{Data Model}
    The core data object returned by the API characterizes the physical device. The IMEI is a 15-digit integer where the first 8 digits are the Type Allocation Code (TAC), identifying the manufacturer and model, followed by a 6-digit serial number.
    
    The following JSON snippet illustrates a typical response payload for the identifier retrieval, including the timestamp of the last verification:
    
    \begin{verbatim}
    {
       "lastChecked": "2024-02-20T10:41:38.657Z",
       "imeisv": "49015420323751800",
       "imei": "4901542032375181",
       "tac": "49015420",
       "model": "3110",
       "manufacturer": "Nokia"
    }
    \end{verbatim}
    
    \begin{figure}[ht]
        \centering
        \includegraphics[width=1\textwidth]{../Figures/Images/Device_Identifier_Overview.png}
        \caption{Device Identifier API operational flow: mapping a network connection or MSISDN to physical device identity \cite{camara_device_identifier}.}
        \label{fig:device_id_overview}
    \end{figure}
    
    \paragraph{Authorization and Addressing}
    To invoke the API, the consumer must identify the mobile subscription. The identification method depends on the authentication flow used:
    \begin{itemize}
        \item {Two-legged Access Token:} The API consumer must explicitly provide a subject identifier in the request body. Supported identifiers include the Phone Number (MSISDN), the IP Address (IPv4 or IPv6), or a Network Access Identifier (NAI). For IPv4, the public port is typically required to handle Carrier-Grade NAT (CGNAT).
        \item {Three-legged Access Token:} The subject identifier {MUST NOT} be provided in the request. The device is uniquely identified implicitly from the access token, which is generated based on user consent during the authentication process.
    \end{itemize}
    
    \paragraph{Multi-SIM Scenario}
    In scenarios where a main phone number is shared between multiple devices (e.g., a smartphone and an eSIM-enabled smartwatch sharing a connectivity plan), ambiguity may arise. The API specification dictates that if a phone number is passed, it is treated as the number associated with the specific device connecting. However, if the "primary" phone number is provided, the API typically returns the identity of the primary device (usually the smartphone) and not the associated secondary devices.
    
    \paragraph{Error Handling}
    The API defines specific HTTP error responses to handle identification issues:
    \begin{itemize}
        \item {404 IDENTIFIER\_NOT\_FOUND:} The device identified in the request is not managed by the API provider.
        \item {422 SERVICE\_NOT\_APPLICABLE:} A device identifier cannot be provided for the target (e.g., the phone number identifies a landline).
        \item {422 MISSING\_IDENTIFIER:} The subject cannot be identified from the access token, and no device object was provided in the request.
        \item {422 UNNECESSARY\_IDENTIFIER:} A device object was provided in the request, but the subject was already identified via a 3-legged access token.
    \end{itemize}
    
    \paragraph{Use Cases}
    The ability to retrieve trusted device information supports several business scenarios:
    \begin{itemize}
        \item {Security and Fraud Prevention:} Establishing that a customer is not using a device they previously reported as lost or stolen, or verifying device possession for authentication.
        \item {Insurance:} Automatically populating device details (make, model, IMEI) when a customer wishes to insure a device, preventing input errors.
        \item {Service Optimization:} Adapting content delivery or software versions based on the specific device model or OS type detected by the network.
    \end{itemize}

    \subsubsection{SIM Swap}
    \label{subsubsec:sim_swap}
    
    \paragraph{Introduction}
    The SIM Swap API performs real-time checks to monitor and detect changes in the Subscriber Identity Module (SIM) card associated with a mobile number. A SIM swap event is defined as a process in which a user's mobile phone number (MSISDN) is associated with a new SIM card (IMSI). This includes scenarios such as replacing a lost or damaged card, upgrading to a new phone, changing providers while keeping the number, or activating a Multi-SIM service \cite{camara_sim_swap}.
    
    \paragraph{Motivation}
    Fraudsters frequently utilize SIM swap techniques to intercept SMS messages, specifically those containing One-Time Passwords (OTP) used for two-factor authentication. By transferring a victim's number to a SIM card in their possession, attackers can reset passwords and gain unauthorized access to protected accounts (Account Takeover Fraud). The SIM Swap API mitigates this risk by strengthening SIM-based authentication processes, allowing Service Providers (SPs) to obtain information about the latest SIM swap date in an easy and secured way to prevent fraud.
    
    \paragraph{Functionality}
    The API offers a programmable interface to query the SIM status through two primary operations:
    \begin{itemize}
        \item {Retrieve Date (`/retrieve-date`):} Provides the timestamp of the latest SIM swap event. If no swap has been performed within the operator's data retention period, the API may return the SIM activation date. If regulations or privacy policies prevent returning the date, a \texttt{null} value is returned.
        \item {Check (`/check`):} Validates whether a SIM swap has occurred during a past period defined by the \texttt{maxAge} attribute (e.g., the last 24 hours). This allows for a boolean verification without exposing the exact timestamp.
    \end{itemize}
    
    \paragraph{Data Model}
    The API typically returns a JSON object containing the timestamp of the last swap or a boolean indicator, depending on the endpoint called.
    
    The following JSON snippet illustrates a response from the \texttt{retrieve-date} endpoint, indicating the precise moment the SIM was last changed:
    
    \begin{verbatim}
    {
      "latestSimSwapTime": "2024-03-20T10:00:00Z"
    }
    \end{verbatim}
    
    \paragraph{Authorization and Addressing}
    To invoke the API, the consumer must identify the phone number as the subject. The method of identification depends on the authorization flow:
    \begin{itemize}
        \item {Two-legged Access Token:} The phone number MUST be explicitly provided in the request body (e.g., via a \texttt{phoneNumber} identifier).
        \item {Three-legged Access Token:} The phone number MUST NOT be provided in the request body. The subject is uniquely identified implicitly from the access token, which is associated with the user during the authentication process.
    \end{itemize}
    
    \paragraph{Multi-SIM Scenario}
    According to the API definition, the activation of a new SIM associated with the same phone number—known as a Multi-SIM service—is considered a SIM swap event. In this context, the MSISDN, which may have been used by another device previously, becomes associated with a SIM card with which it was not associated before.
    
    \paragraph{Error Handling}
    The API defines specific error codes to handle invalid requests or privacy constraints:
    \begin{itemize}
        \item {400 OUT\_OF\_RANGE:} The \texttt{maxAge} parameter in a check request exceeds the operator's allowed monitoring period (e.g., 2400 hours) or local regulations.
        \item {422 MISSING\_IDENTIFIER:} The phone number cannot be identified from the access token and was not included in the request body.
        \item {422 UNNECESSARY\_IDENTIFIER:} A phone number was provided in the request body, but the subject was already identified via a 3-legged access token.
        \item {501 NOT\_IMPLEMENTED:} Returned if a specific functionality is explicitly not supported by the implementation.
    \end{itemize}
    
    \paragraph{Use Cases}
    The ability to verify the integrity of the SIM-MSISDN association enables several critical security applications:
    \begin{itemize}
        \item {Fraud Prevention in Banking:} Financial institutions can query the API during suspicious transactions to ensure the user's SIM has not been compromised recently.
        \item {Password Reset Protection:} Online service providers (e-commerce, social networks) can verify SIM status before sending SMS OTPs for password recovery to prevent account takeover.
        \item {Non-Automated Actions:} Supporting call center experts by confirming the stability of the user's line before performing sensitive operations manually.
    \end{itemize}

    \subsubsection{Location Retrieval}
    \label{subsubsec:location_retrieval}
    
    \paragraph{Introduction}
    The Location Retrieval API provides the ability for API consumers to retrieve the geographic area where a specific user device is localized, as detected by the mobile network operator. Unlike GPS-based solutions, this location is derived from network infrastructure. The area provided in the response is described either as a circle (determined by latitude, longitude, and radius) or as a simple polygon (delimited by a series of connected coordinates), depending on the network conditions and capabilities \cite{camara_location_retrieval}.
    
    \paragraph{Motivation}
    Mobile network location detection provides a trusted method for verifying geographic presence, offering a layer of "Reliable \& Fraud-Resistant Location Intelligence". While devices can report their own location via GPS, this data can be spoofed or unavailable (e.g., indoors). Network-based retrieval ensures fair access to region-locked content and secure transaction approvals by minimizing fraud risks (such as fake GPS coordinates) and improving operational efficiency without adding friction for legitimate users.
    
    \paragraph{Functionality}
    The API exposes a single endpoint (`/retrieve`) to obtain the device location. The requester can optionally constrain the quality of the data using two parameters:
    \begin{itemize}
        \item {Max Age (`maxAge`):} Specifies the maximum acceptable age of the location information in seconds. A value of `0` requests a fresh calculation. If omitted, any cached age is acceptable.
        \item {Max Surface (`maxSurface`):} Specifies the maximum acceptable surface area in square meters. This controls the accuracy; if the network cannot locate the device within this limit, it returns an error.
    \end{itemize}
    
    \paragraph{Data Model}
    The API returns a JSON object containing the location area and a timestamp (`lastLocationTime`) indicating when the device was localized.
    
    The following JSON snippet illustrates a typical response where the area is defined as a circle:
    
    \begin{verbatim}
    {
      "lastLocationTime": "2023-10-17T13:18:23.682Z",
      "area": {
        "areaType": "CIRCLE",
        "center": {
          "latitude": 45.754114,
          "longitude": 4.860374
        },
        "radius": 800
      }
    }
    \end{verbatim}
    
    \paragraph{Authorization and Addressing}
    To invoke the API, the consumer must identify the target device. The identification method relies on the authentication flow:
    \begin{itemize}
        \item {Two-legged Access Token:} The subject must be identified from an optional `device` object in the request body (e.g., PhoneNumber, IPv4, IPv6).
        \item {Three-legged Access Token:} The `device` object MUST NOT be provided. The subject is uniquely identified from the access token itself, ensuring transparency and compliance with user-centric privacy-by-design principles.
    \end{itemize}
    
    \paragraph{Multi-SIM Scenario}
    In scenarios where a single phone number is associated with multiple devices (e.g., a smartphone and a smartwatch), identifying the specific device to locate can be ambiguous. The API specification notes that the operator may return the location of a single "primary" device, a combined location, or an error. To make this scenario deterministic, the specification recommends:
    \begin{itemize}
        \item Using the authorization code flow (3-legged token) to automatically identify the intended device.
        \item Identifying the device via its source IP address and port rather than just the phone number.
        \item Using a unique "secondary" phone number if available for the specific device.
    \end{itemize}
    
    \paragraph{Error Handling}
    The API utilizes specific HTTP error codes to communicate retrieval failures:
    \begin{itemize}
        \item {422 UNABLE\_TO\_LOCATE:} The system cannot determine the device's location.
        \item {422 UNABLE\_TO\_FULFILL\_MAX\_AGE:} The system cannot provide location data fresher than the requested `maxAge`.
        \item {422 UNABLE\_TO\_FULFILL\_MAX\_SURFACE:} The system cannot provide an area within the requested `maxSurface` limit.
        \item {404 IDENTIFIER\_NOT\_FOUND:} The provided identifier cannot be matched to a known device.
    \end{itemize}
    
    \paragraph{Use Cases}
    Trusted location data supports various critical scenarios:
    \begin{itemize}
        \item {Fraud Prevention:} Verifying if a financial transaction or high-value purchase originates from a location consistent with the user's expected region.
        \item {Contextual Advertising:} Triggering promotions only when verifying the device is physically within a specific area of interest (e.g., a shopping district).
        \item {Smart Mobility:} Obtaining the location of shared vehicles (bikes/scooters) to guarantee they are rented or parked correctly.
        \item {Emergency Services:} Providing accurate location information to responders when GPS is unavailable.
    \end{itemize}

    \subsubsection{Location Verification}
    \label{subsubsec:location_verification}
    
    \paragraph{Introduction}
    The Location Verification API allows API consumers to verify whether a specific mobile device is physically present within a specified geographical area. Currently, the supported area is defined as a circle, determined by a set of coordinates (latitude and longitude) and an accuracy radius. Unlike retrieval services, the response provides a confirmation (verification result) rather than exposing the exact coordinates, adhering to privacy constraints \cite{camara_location_verification}.
    
    \paragraph{Motivation}
    This API is designed to protect clients from fraud risks associated with identity exploitation or data theft while protecting the legitimate interests of Service Providers. By relying on network-based verification rather than client-side GPS, it prevents common spoofing methods such as the use of VPNs or fake GPS apps. This approach enhances customer trust and ensures compliance with security regulations without requiring the handling of sensitive coordinate data.
    
    \paragraph{Functionality}
    The API exposes a single endpoint (`/verify`) that triggers a process to confirm or contradict the client's assumption about the device location. The verification logic produces three possible outcomes:
    \begin{itemize}
        \item {TRUE:} The network's estimation of the device's location is fully contained within the requested area.
        \item {FALSE:} The device location does not overlap with the requested area at all.
        \item {PARTIAL:} The device location partially overlaps or fully contains the requested area (because the network area is larger). In this case, a `matchRate` percentage may be included to estimate the likelihood of the match.
    \end{itemize}
    Clients can also specify a `maxAge` parameter. If the location information known to the server is older than this value, an error is returned independently of the result.
    
    \paragraph{Data Model}
    The core response object contains the boolean-like verification result and optionally the time of the last location check. 
    
    The following JSON snippet illustrates a response where the verification was successful (Partial match) with a specific probability:
    
    \begin{verbatim}
    {
      "lastLocationTime": "2024-03-20T14:30:00Z",
      "verificationResult": "PARTIAL",
      "matchRate": 85
    }
    \end{verbatim}
    
    \paragraph{Authorization and Addressing}
    To invoke the API, the consumer must identify the device. The methodology is dictated by the token type:
    \begin{itemize}
        \item {Two-legged Access Token:} The subject must be explicitly identified via the `device` object (e.g., PhoneNumber, IPv4) in the request body.
        \item {Three-legged Access Token:} The `device` object {MUST NOT} be provided. The subject is uniquely identified from the access token, which is mandatory when users exercise rights such as opt-in/opt-out for personal data processing.
    \end{itemize}
    
    \paragraph{Multi-SIM Scenario}
    When a phone number is associated with multiple devices (e.g., Multi-SIM), the API provider may return an error, the status of the primary device, or a combined verification value. To ensure deterministic behavior, the specification suggests:
    \begin{itemize}
        \item Using the authorization code flow (3-legged token) to automatically identify the intended device.
        \item Using identifiers like Source IP and Port instead of just the phone number.
        \item Using a unique "secondary" phone number if available.
    \end{itemize}
    
    \paragraph{Error Handling}
    The API defines specific error codes for location constraints:
    \begin{itemize}
        \item {422 AREA\_NOT\_COVERED:} The provided area is outside the operator's coverage.
        \item {422 INVALID\_AREA:} Legal restrictions or implementation issues force the operator to reject the area (e.g., the requested radius is too small for privacy compliance).
        \item {422 UNABLE\_TO\_LOCATE:} The network cannot locate the device.
        \item {422 UNABLE\_TO\_FULFILL\_MAX\_AGE:} Fresh location data cannot be obtained within the requested `maxAge`.
    \end{itemize}
    
    \paragraph{Use Cases}
    The verification model supports high-security and geo-compliance scenarios:
    \begin{itemize}
        \item {FinTech Fraud Prevention:} Banks can verify if a user attempting a transaction in a specific city is physically present there, detecting card cloning or remote attacks.
        \item {Geo-blocking and Content Rights:} Media services can verify if a user is in an authorized region for streaming content, preventing VPN circumvention.
        \item {Smart Mobility:} Confirming that a rented vehicle (bike/scooter) is located within a valid parking zone before ending the rental session.
    \end{itemize}

    \subsubsection{QoS Profiles}
    \label{subsubsec:qos_profiles}
    
    \paragraph{Introduction}
    The QoS Profiles API provides a standardized mechanism for API consumers to discover the Quality of Service (QoS) profiles available for a mobile subscription. Rather than modifying the network state directly, this API allows applications to query the catalogue of supported service levels (e.g., "Low Latency", "High Throughput") that the network operator currently offers for a specific device or connection context \cite{camara_qos_profiles}.
    
    \paragraph{Motivation}
    In mobile networks, QoS is technically managed through complex 3GPP parameters such as 5G QoS Identifiers (5QI), Allocation and Retention Priority (ARP), or QCI. Application developers, however, typically define requirements in business terms. The QoS Profiles API bridges this gap by abstracting complex network configurations into human-readable profile names. This abstraction decouples the application logic from the underlying radio access technology, simplifying integration and ensuring forward compatibility.
    
    \paragraph{Functionality}
    The API exposes a retrieval operation (typically `GET /qos-profiles`) that returns a list of QoS profiles. The response includes the profile name, a description, and its current status. This allows the API consumer to dynamically verify which profiles are valid to use in subsequent Quality on Demand (QoD) requests for a specific user.
    
    \paragraph{Data Model}
    The API returns a JSON array of profile objects. Each object typically contains the unique name (used as a key in QoD requests), a human-readable description, and the operational status.
    
    The following JSON snippet illustrates a typical response where the network offers a generic high-priority profile and a specific low-latency profile:
    
    \begin{verbatim}
    [
      {
        "name": "QOS_E",
        "description": "Standard high-priority profile",
        "status": "ACTIVE"
      },
      {
        "name": "QOS_L",
        "description": "Low Latency profile for real-time applications",
        "status": "ACTIVE"
      }
    ]
    \end{verbatim}
    
    \paragraph{Authorization and Addressing}
    To invoke the API, the consumer must identify the target subscription to determine eligibility. The addressing follows the standard CAMARA security profile:
    \begin{itemize}
        \item {Two-legged Access Token:} The consumer must provide the device identifier (e.g., Phone Number, IPv4 address) in the query parameters or request body.
        \item {Three-legged Access Token:} The device identifier is derived implicitly from the token (bound to the user's consent), and explicit identifiers in the request are omitted.
    \end{itemize}
    
    \paragraph{Multi-SIM Scenario}
    When the subscription identifier corresponds to a multi-SIM setup (e.g., OneNumber service), the available QoS profiles might differ between the primary device (smartphone) and secondary devices (e.g., wearables). The API provider's implementation determines whether the response aggregates profiles for all devices or reflects only the primary device. To ensure deterministic results, using a 3-legged token or identifying the device by IP address is recommended.
    
    \paragraph{Error Handling}
    The API uses standard HTTP error codes to indicate retrieval issues:
    \begin{itemize}
        \item {401 UNAUTHENTICATED:} The access token is missing or invalid.
        \item {403 PERMISSION\_DENIED:} The client does not have the scope to read QoS profiles.
        \item {404 IDENTIFIER\_NOT\_FOUND:} The requested device or subscription could not be found.
        \item {501 NOT\_IMPLEMENTED:} The discovery functionality is not supported by the specific operator implementation.
    \end{itemize}
    
    \paragraph{Use Cases}
    The discovery capability enables adaptive application behavior:
    \begin{itemize}
        \item {Pre-flight Validation:} A cloud gaming application can check if the `QOS\_L` (Low Latency) profile is available before starting a session. If unavailable (e.g., due to the user's plan or roaming status), the app can adjust settings or notify the user.
        \item {Roaming Adaptation:} Since QoS profile names and availability may vary between roaming partners, applications can use this API to dynamically discover the valid profiles in the visited network.
    \end{itemize}

    \subsubsection{Quality on Demand (QoD)}
    \label{subsubsec:quality_on_demand}
    
    \paragraph{Introduction}
    The Quality on Demand (QoD) API allows API consumers to request a specific Quality of Service (QoS) for a mobile device connection. Unlike the standard "best-effort" traffic handling, this API enables applications to request stable latency, prioritized throughput, or reduced jitter for a defined duration. The service operates by creating a temporary "QoS Session" between the application and the network operator \cite{camara_quality_on_demand}.
    
    \paragraph{Motivation}
    In traditional mobile networks, traffic is managed dynamically, meaning performance can fluctuate based on cell congestion. This lack of determinism is problematic for real-time applications such as cloud gaming, remote machinery control, or autonomous mobility. The QoD API addresses this by allowing developers to programmatically "book" network resources, effectively translating business requirements (e.g., "I need a stable connection for 10 minutes") into network enforcement policies without requiring deep knowledge of telecommunications protocols.
    
    \paragraph{Functionality}
    The core capability of the API is the creation and management of QoS sessions. The primary endpoint (`POST /sessions`) allows the consumer to instantiate a session by specifying:
    \begin{itemize}
        \item {Device:} The target user (identified by IP or Phone Number).
        \item {QoS Profile:} The desired service level (e.g., `QOS\_L` for Low Latency), which determines the specific network parameters applied.
        \item {Duration:} The requested lifetime of the session in seconds.
    \end{itemize}
    The API also supports retrieving session status (`GET /sessions/{sessionId}`) and deleting sessions (`DELETE /sessions/{sessionId}`) to release resources early.
    
    \paragraph{Data Model}
    The API revolves around the Session object. The request requires a device identifier and a profile name, while the response provides a unique `sessionId`, the status, and expiration timestamps.
    
    The following JSON snippet illustrates a request to create a 10-minute session using a Low Latency profile for a specific IP address:
    
    \begin{verbatim}
    // POST /sessions
    Request:
    {
      "qosProfile": "QOS_L",
      "device": {
        "ipv4Address": {
          "publicAddress": "84.125.93.10",
          "publicPort": 59765
        }
      },
      "duration": 600
    }
     
    Response:
    {
      "sessionId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "qosStatus": "ACTIVE",
      "startedAt": "2024-03-20T10:00:00Z",
      "expiresAt": "2024-03-20T10:10:00Z"
    }
    \end{verbatim}
    
    \paragraph{Authorization and Addressing}
    To enforce QoS, the network must identify the specific flow or subscriber.
    \begin{itemize}
        \item {Two-legged Access Token:} The consumer explicitly provides the device identifier. In QoD, identifying the device by {IPv4/IPv6 address} is often preferred over the Phone Number, as it allows the network to apply QoS policies to the specific data flow associated with that IP connection.
        \item {Three-legged Access Token:} The subject is identified from the token. However, for precise traffic prioritization (e.g., applying QoS only to the gaming traffic and not background downloads), the application source IP might still be required in the session creation context.
    \end{itemize}
    
    \paragraph{Multi-SIM Scenario}
    In Multi-SIM environments, applying QoS requires identifying the specific active connection. If a phone number is used, the network might apply the policy to the primary SIM or fail if ambiguous. Therefore, the specification strongly implies that using the IP address (which is unique to the active data session) is the most deterministic method to target the correct device in a multi-SIM setup.
    
    \paragraph{Error Handling}
    The API defines specific errors to handle resource contention and validation:
    \begin{itemize}
        \item {409 CONFLICT:} A session already exists for this device, or the request conflicts with an existing policy.
        \item {422 QOS\_PROFILE\_NOT\_FOUND:} The requested profile name (e.g., `QOS\_L`) is not valid or available for this user.
        \item {422 UNAVAILABLE:} The network cannot fulfill the QoS request at the current location due to congestion or lack of resources.
        \item {501 NOT\_IMPLEMENTED:} The requested duration or profile features are not supported by the operator.
    \end{itemize}
    
    \paragraph{Use Cases}
    QoD enables a new class of network-aware applications:
    \begin{itemize}
        \item {Real-Time Immersion (XR/Gaming):} Requesting low latency to minimize motion-to-photon delay in VR headsets or cloud gaming, preventing motion sickness.
        \item {Remote Operations (Tele-driving):} Ensuring command signals for drones or industrial robots arrive within a strict time window to guarantee safety.
        \item {Critical Communications:} Prioritizing video streams or control data for emergency response devices in congested areas.
    \end{itemize}

\section{Real-World CAMARA-Based Use Cases}
\label{sec:real_world_use_cases}

The transition of CAMARA APIs from specification to deployment is already visible across several industries. Early adopters have demonstrated that exposing network capabilities through standardized APIs significantly enhances security, user experience, and operational efficiency. This section highlights key implementations that validate the potential of the APIs described previously.

\subsection{FinTech and E-Commerce Security}
The financial and retail sectors have been primary adopters of identity-focused APIs to combat fraud and reduce friction during user onboarding.

\begin{itemize}
    \item {Vinted (Number Verify):} The marketplace platform Vinted integrated the \textit{Number Verify API} to replace traditional SMS-based One-Time Passwords (OTPs). By verifying the user's phone number silently in the background, they significantly reduced transaction friction and registration drop-offs while maintaining high security standards \cite{telefonica_vinted}.
    \item {Itaú Unibanco (Location \& SIM Swap):} One of the largest banks in Latin America, Itaú, utilized CAMARA APIs to secure financial transactions. By leveraging \textit{Location Verification} and \textit{SIM Swap} checks, the bank can detect if a transaction is originating from a trusted device and location, effectively blocking attempts at account takeover fraud \cite{telefonica_itau}.
    \item {Currencies Direct (Fraud Protection):} This financial service provider implemented GSMA Open Gateway APIs to strengthen customer onboarding, ensuring that identity verification processes are both compliant and resistant to spoofing attacks \cite{gsma_currencies_direct}.
\end{itemize}

\subsection{Immersive Entertainment and Broadcasting}
For applications requiring high bandwidth and low latency, the \textit{Quality on Demand (QoD)} API has proven essential in moving from "best-effort" to deterministic network performance.

\begin{itemize}
    \item {Blacknut (Cloud Gaming):} In collaboration with Telefónica, Blacknut integrated the \textit{QoD API} to guarantee stable throughput and low latency for cloud gaming. This ensures that users experience console-quality graphics and responsiveness on mobile networks, mitigating the impact of cell congestion \cite{telefonica_blacknut}.
    \item {Cinfo (Event Broadcasting):} Specialized in AI-driven video production, Cinfo uses the \textit{QoD API} to reserve guaranteed uplink bandwidth. This allows cameras to stream high-definition sports events live from stadiums via 5G without relying on expensive satellite or fiber connections \cite{telefonica_cinfo}.
    \item {Kanto (Interactive Media):} The interactive karaoke application Kanto utilizes network APIs to synchronize lyrics and video streams with minimal latency, ensuring a seamless sing-along experience for users on mobile connections \cite{telefonica_kanto}.
\end{itemize}

\subsection{Healthcare and Remote Mobility}
In critical sectors where network failure can have physical consequences, CAMARA APIs provide the necessary reliability layers.

\begin{itemize}
    \item {Apoqlar (HoloMedicine):} This medical technology company uses the \textit{QoD API} to support "VSI HoloMedicine". The API ensures the necessary bandwidth to stream complex 3D medical images and mixed reality overlays to surgeons' HoloLens glasses in real-time, facilitating remote collaboration and surgical planning \cite{telefonica_apoqlar}.
    \item {Elmo (Remote Driving):} In a pilot with Nokia and Elisa, the rental company Elmo utilized network APIs to remotely control vehicles. The implementation relies on prioritized network slices to ensure that video feeds and control signals are transmitted without interruption, which is critical for the safety of remote driving operations \cite{nokia_elmo}.
\end{itemize}

These real-world integrations demonstrate that CAMARA APIs are not merely theoretical specifications but are actively solving connectivity and security challenges, driving value for both developers and network operators.

\section{Summary of the Chapter}
\label{sec:chapter_summary}

This chapter explored the evolution of mobile networks towards programmable platforms, highlighting the transition from rigid legacy infrastructures to flexible, software-based architectures. We identified that despite these advances, the fragmentation of interfaces across different operators has historically hindered the scalability of third-party applications. The CAMARA initiative addresses this critical challenge by providing a unified service exposure layer, abstracting the complexity of the underlying network and ensuring consistent API behavior globally.

The technical analysis confirmed that the specific APIs selected for this project—Device Identifier and SIM Swap for identity security, Location Retrieval and Verification for geolocation, and Quality on Demand for network performance—provide the necessary capabilities to bridge the gap between network resources and application needs. These standardized interfaces offer the precise tools required to develop value-generating applications without requiring deep telecommunications expertise.

With the technological foundation established and the enabling tools identified, the context is set for the practical implementation. The following chapter will present the planning and methodology, defining the work plan to leverage these APIs in the development of the prototype.